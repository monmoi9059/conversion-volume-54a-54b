<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LES RATS DE QUAI LE JEU OFFICIEL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            background-color: #020617;
            display: block;
            touch-action: none;
            cursor: pointer;
        }
        .game-container {
            position: relative; /* Needed for absolute positioning of the UI */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #gameCanvas {
            border: 4px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #character-select-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none; /* Hidden by default */
            width: 80%;
            max-width: 500px;
        }
        .char-select-arrow {
            font-size: 3rem;
            cursor: pointer;
            text-shadow: 2px 2px #000;
            padding: 1rem;
            user-select: none;
        }
        .char-select-arrow:hover {
            color: #FBBF24;
        }
        #ability-desc {
            font-size: 0.8rem;
            color: #cbd5e1;
            margin-top: 1rem;
            height: 40px; /* Reserve space */
        }
    </style>
</head>
<body class="antialiased">
    <div class="game-container">
        <div class="text-center">
            <h1 id="title" class="text-3xl lg:text-5xl text-yellow-300 mb-4" style="text-shadow: 2px 2px #000;">LES RATS DE QUAI</h1>
            <canvas id="gameCanvas"></canvas>
            <p id="instructions" class="mt-4 text-sm lg:text-base">Space: Jump | ArrowDown: Duck | E: Ability | P: Pause</p>
        </div>
        
        <div id="character-select-ui">
            <h2 class="text-2xl mb-4" style="text-shadow: 2px 2px #000;">CHOOSE YOUR RUNNER</h2>
            <div class="flex items-center justify-between">
                <div id="prev-char" class="char-select-arrow">&lt;</div>
                <div class="flex-grow">
                    <h3 id="char-name" class="text-xl text-yellow-300">RAT</h3>
                </div>
                <div id="next-char" class="char-select-arrow">&gt;</div>
            </div>
             <p id="ability-desc">Ability: Coin Magnet</p>
             <button id="select-char-btn" class="mt-2 bg-yellow-500 text-gray-900 font-bold py-2 px-6 rounded-lg border-b-4 border-yellow-700 hover:bg-yellow-400">
                SELECT
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const titleElement = document.getElementById('title');
        const instructionsElement = document.getElementById('instructions');
        const charSelectUI = document.getElementById('character-select-ui');
        const charNameElement = document.getElementById('char-name');
        const prevCharButton = document.getElementById('prev-char');
        const nextCharButton = document.getElementById('next-char');
        const selectCharButton = document.getElementById('select-char-btn');
        const abilityDescElement = document.getElementById('ability-desc');

        let canvasWidth = 800;
        let canvasHeight = 400;

        let score;
        let highscore = localStorage.getItem('refineryRatHighscore') || 0;
        let gameSpeed;
        let obstacles = [];
        let coins = [];
        let powerups = []; 
        let scorePopups = [];
        let platforms = [];
        let frame = 0;
        let gameState = 'characterSelect';
        let speedBoostMessage = { text: '', alpha: 0, timer: 0 };
        let selectedAnimalIndex = 0;
        let activePowerup = null; 
        let powerupTimer = 0;
        const POWERUP_DURATION = 420;
        const GRAVITY = 0.5;
        const JUMP_STRENGTH = -13.5;
        const INITIAL_GAME_SPEED = 4;
        const GAME_SPEED_INCREASE = 0.001;
        const GROUND_HEIGHT = canvasHeight - 50;

        const animals = [
            {
                name: "RAT",
                width: 70, height: 40,
                abilityDesc: "Ability: Coin Magnet",
                abilityDuration: 180, 
                abilityCooldownTime: 600,
                draw: function(player) {
                    ctx.strokeStyle = '#2a201d'; ctx.lineWidth = 0.5;
                    const bodyGradient = ctx.createLinearGradient(0, -player.height*0.5, 0, player.height*1.5);
                    bodyGradient.addColorStop(0, '#a69086'); bodyGradient.addColorStop(0.5, '#745d54'); bodyGradient.addColorStop(1, '#4f3b35');
                    ctx.fillStyle = '#c5a9a9'; ctx.beginPath();
                    const tailOffsetY = player.currentFrame === 0 && !player.isJumping ? 2 : 0;
                    ctx.moveTo(5, player.height * 0.7);
                    ctx.bezierCurveTo(-10, player.height*1.1 + tailOffsetY, -30, player.height, -40, player.height*0.8);
                    ctx.bezierCurveTo(-25, player.height*0.4 + tailOffsetY, 0, player.height*0.6, 5, player.height*0.7);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = bodyGradient;
                    const legX1 = player.currentFrame === 0 ? player.width * 0.2 : player.width * 0.45;
                    const legX2 = player.currentFrame === 0 ? player.width * 0.7 : player.width * 0.55;
                    if (!player.isJumping) {
                        ctx.beginPath(); ctx.ellipse(legX1, player.height * 0.95, player.width*0.2, player.width*0.12, 0.5, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
                        ctx.beginPath(); ctx.ellipse(legX2, player.height * 0.9, player.width*0.18, player.width*0.11, -0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
                    }
                    ctx.beginPath();
                    ctx.moveTo(0, player.height * 0.7);
                    ctx.bezierCurveTo(player.width * 0.2, -player.height * 0.4, player.width * 0.6, -player.height * 0.2, player.width * 0.8, player.height * 0.5);
                    ctx.ellipse(player.width * 0.25, player.height * 0.7, player.width * 0.3, player.height * 0.4, 0.2, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(player.width * 0.85, player.height * 0.6, player.width * 0.25, player.height * 0.3, -0.2, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(player.width*0.9, player.height*0.6); ctx.bezierCurveTo(player.width*1.05, player.height*0.7, player.width*1.05, player.height*0.9, player.width*0.95, player.height);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#c5a9a9'; ctx.beginPath(); ctx.ellipse(player.width*0.5, player.height*0.3, 8, 10, 0.8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(player.width*0.5, player.height*0.3, 5, 7, 0.8, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(player.width*0.88, player.height*0.5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(player.width*0.9, player.height*0.48, 1, 0, Math.PI*2); ctx.fill();
                }
            },
            {
                name: "RATON LAVEUR",
                width: 75, height: 45,
                abilityDesc: "Ability: Break Obstacle",
                abilityDuration: 5, 
                abilityCooldownTime: 900,
                draw: function(player) {
                    ctx.strokeStyle = '#111827'; ctx.lineWidth = 1;
                    const tailGrad = ctx.createLinearGradient(-70, 0, 0, 0);
                    tailGrad.addColorStop(0, '#6B7280'); tailGrad.addColorStop(0.15, '#1F2937'); tailGrad.addColorStop(0.3, '#6B7280');
                    tailGrad.addColorStop(0.45, '#1F2937'); tailGrad.addColorStop(0.6, '#6B7280'); tailGrad.addColorStop(0.75, '#1F2937');
                    ctx.fillStyle = tailGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, player.height*0.8); ctx.bezierCurveTo(-40, player.height*1.2, -60, player.height*0.2, -70, player.height*0.6);
                    ctx.bezierCurveTo(-60, player.height*1.2, -40, player.height*1.4, 0, player.height*0.8);
                    ctx.fill(); ctx.stroke();
                    const bodyGradient = ctx.createLinearGradient(0, -player.height*0.3, 0, player.height);
                    bodyGradient.addColorStop(0, '#9CA3AF'); bodyGradient.addColorStop(1, '#374151');
                    ctx.fillStyle = bodyGradient;
                    const legX1 = player.currentFrame === 0 ? player.width * 0.15 : player.width * 0.45;
                    const legX2 = player.currentFrame === 0 ? player.width * 0.75 : player.width * 0.6;
                    if(!player.isJumping) {
                        ctx.beginPath(); ctx.ellipse(legX1, player.height, player.width*0.25, player.width*0.1, 0.4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(legX2, player.height, player.width*0.22, player.width*0.1, -0.2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.ellipse(player.width*0.3, player.height*0.7, player.width*0.4, player.height*0.4, 0, 0, Math.PI*2);
                    ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(player.width*0.75, player.height*0.5, player.width*0.3, player.height*0.35, -0.3, 0, Math.PI*2);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(player.width*0.75, player.height*0.5, player.width*0.28, player.height*0.3, -0.3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#1F2937'; ctx.beginPath(); ctx.ellipse(player.width*0.78, player.height*0.55, player.width*0.2, player.height*0.25, -0.3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(player.width*0.85, player.height*0.45, 4, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(player.width*0.86, player.height*0.45, 2, 0, Math.PI*2); ctx.fill();
                }
            },
            {
                name: "ÉCUREUIL",
                width: 70, height: 50,
                abilityDesc: "Ability: Glide",
                abilityDuration: 120, 
                abilityCooldownTime: 480,
                draw: function(player) {
                    ctx.strokeStyle = '#4d2c1d'; ctx.lineWidth = 1;
                    const tailGrad = ctx.createLinearGradient(0,-player.height,0,player.height);
                    tailGrad.addColorStop(0, '#d97706'); tailGrad.addColorStop(1, '#92400e');
                    ctx.fillStyle = tailGrad;
                    ctx.beginPath(); ctx.moveTo(0, player.height * 0.8);
                    ctx.bezierCurveTo(30, -player.height*0.7, 70, -player.height*0.4, 50, player.height);
                    ctx.bezierCurveTo(40, player.height*0.5, 20, player.height*0.4, 0, player.height*0.8);
                    ctx.closePath(); ctx.fill(); ctx.stroke();
                    const bodyGradient = ctx.createLinearGradient(0, 0, 0, player.height);
                    bodyGradient.addColorStop(0, '#f59e0b'); bodyGradient.addColorStop(1, '#b45309');
                    ctx.fillStyle = bodyGradient;
                    const legX1 = player.currentFrame === 0 ? player.width * 0.2 : player.width * 0.45;
                    const legX2 = player.currentFrame === 0 ? player.width * 0.7 : player.width * 0.55;
                     if(!player.isJumping) {
                        ctx.beginPath(); ctx.ellipse(legX1, player.height*0.9, player.width*0.15, player.width*0.1, 0.4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(legX2, player.height*0.9, player.width*0.15, player.width*0.1, -0.2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    }
                    ctx.beginPath(); ctx.moveTo(10, player.height*0.6); ctx.bezierCurveTo(20,-5, 50, 0, 55, player.height*0.7);
                    ctx.lineTo(50, player.height); ctx.lineTo(15, player.height); ctx.closePath(); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fef3c7'; ctx.beginPath(); ctx.ellipse(35, player.height*0.8, 15, 8, 0.3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(50, player.height*0.5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(51, player.height*0.48, 0.8, 0, Math.PI*2); ctx.fill();
                }
            }
        ];

        const player = { x: 100, y: GROUND_HEIGHT-35, originalWidth: 60, originalHeight: 35, width: 60, height: 35, velocityY: 0, isJumping: false, isDucking: false, jumpCount: 0, canDoubleJump: false, isJumpButtonHeld: false, animationTimer: 0, currentFrame: 0, animal: animals[0], 
            abilityCooldown: 0, abilityTimer: 0, abilityActive: false,
            setCharacter(animalData) { this.animal = animalData; this.originalWidth = animalData.width; this.originalHeight = animalData.height; this.width = animalData.width; this.height = animalData.height; this.y = GROUND_HEIGHT - this.height; }, 
            draw() { ctx.save(); ctx.translate(this.x, this.y); if (activePowerup === 'shield') { const pulse = 0.3 + Math.sin(frame * 0.1) * 0.2; ctx.fillStyle = `rgba(56, 189, 248, ${pulse})`; ctx.beginPath(); ctx.ellipse(this.width / 2, this.height / 2, this.width * 0.8, this.height * 1.2, 0, 0, Math.PI * 2); ctx.fill(); } if (this.isDucking) { ctx.translate(0, this.height); ctx.scale(1.15, 0.6); ctx.translate(0, -this.height); } this.animal.draw(this); ctx.restore(); }, 
            update() {
                if (this.isJumping && this.isDucking) { this.standUp(); }
                let onPlatform = false; let lastY = this.y;
                this.velocityY += GRAVITY;
                if(this.animal.name === "ÉCUREUIL" && this.abilityActive && this.velocityY > 0) { this.velocityY -= GRAVITY * 0.6; }
                this.y += this.velocityY;

                for(const platform of platforms) {
                    const playerBottom = this.y + this.height; const playerLastBottom = lastY + this.height; const playerRight = this.x + this.width;
                    if (playerRight > platform.x && this.x < platform.x + platform.width && playerBottom >= platform.y && playerLastBottom <= platform.y) {
                         this.y = platform.y - this.height; this.velocityY = 0; this.isJumping = false; this.jumpCount = 0; onPlatform = true;
                         break;
                    }
                }
                if (!this.isJumping) {
                    this.animationTimer++;
                    if (this.animationTimer > 5) { this.currentFrame = (this.currentFrame + 1) % 2; this.animationTimer = 0; }
                }
                if(this.y > canvasHeight + 50) { gameState = 'gameOver'; }
                if(this.abilityCooldown > 0) this.abilityCooldown--;
                if(this.abilityTimer > 0) {
                    this.abilityTimer--;
                    if(this.abilityTimer <= 0) this.abilityActive = false;
                }
            }, 
            activateAbility() { if(this.abilityCooldown <= 0) { this.abilityActive = true; this.abilityTimer = this.animal.abilityDuration; this.abilityCooldown = this.animal.abilityCooldownTime; } },
            jump() { if (!this.isJumping) { this.velocityY = JUMP_STRENGTH; this.isJumping = true; this.jumpCount = 1; } else if (this.canDoubleJump && this.jumpCount < 2) { this.velocityY = JUMP_STRENGTH * 0.9; this.jumpCount = 2; } }, duck() { if (!this.isJumping) { this.isDucking = true; this.height = this.originalHeight / 2; this.width = this.originalWidth * 1.1; this.y = GROUND_HEIGHT - this.height; } }, standUp() { this.isDucking = false; this.height = this.originalHeight; this.width = this.originalWidth; this.y = GROUND_HEIGHT - this.height; } };
        class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.width = 30; this.height = 30; this.type = type; } draw() { ctx.save(); ctx.translate(this.x, this.y); if (this.type === 'shield') { ctx.fillStyle = '#0ea5e9'; ctx.strokeStyle = '#f0f9ff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.width / 2, 0); ctx.lineTo(0, this.height / 4); ctx.lineTo(0, this.height * 0.7); ctx.arcTo(this.width / 2, this.height + 5, this.width, this.height * 0.7, 20); ctx.lineTo(this.width, this.height / 4); ctx.closePath(); ctx.fill(); ctx.stroke(); } else if (this.type === 'doubleJump') { ctx.fillStyle = '#e5e7eb'; ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, this.height); ctx.quadraticCurveTo(this.width, -this.height * 0.5, this.width, this.height); ctx.quadraticCurveTo(this.width * 0.4, this.height * 0.5, 0, this.height); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.width * 0.5, this.height); ctx.lineTo(this.width * 0.8, this.height * 0.2); ctx.stroke(); } ctx.restore(); } update() { this.x -= gameSpeed; } }
        class Coin { constructor(x, y) { this.x = x; this.y = y; this.radius = 12; this.value = Math.floor(Math.random() * 101) + 50; this.animationFrame = 0; this.animationSpeed = 0.2; this.spriteWidths = [1, 4, 8, 11, 12, 11, 8, 4]; } draw() { const currentWidth = this.spriteWidths[Math.floor(this.animationFrame)]; this.animationFrame = (this.animationFrame + this.animationSpeed) % this.spriteWidths.length; const grad = ctx.createLinearGradient(this.x - currentWidth, this.y - this.radius, this.x + currentWidth, this.y + this.radius); grad.addColorStop(0, '#FBBF24'); grad.addColorStop(0.5, '#FDE68A'); grad.addColorStop(1, '#D97706'); ctx.fillStyle = grad; ctx.strokeStyle = '#B45309'; ctx.lineWidth = 1; ctx.beginPath(); ctx.ellipse(this.x, this.y, currentWidth, this.radius, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } update() { this.x -= gameSpeed; } }
        class ScorePopup { constructor(x, y, value) { this.x = x; this.y = y; this.value = `+${value}`; this.life = 60; this.alpha = 1; } update() { this.y -= 0.5; this.life--; this.alpha = this.life / 60; } draw() { ctx.save(); ctx.textAlign = 'center'; ctx.font = '14px "Press Start 2P"'; ctx.fillStyle = `rgba(251, 191, 36, ${this.alpha})`; ctx.fillText(this.value, this.x, this.y); ctx.restore(); } }
        class Obstacle { constructor(type, x, y, width, height, color) { this.type = type; this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; this.wingFrame = 0; } 
            update() { 
                this.x -= gameSpeed;
                if (this.type === 'seagull') { this.y += Math.sin(frame * 0.05) * 0.5; } 
            }
            draw() { ctx.save(); ctx.translate(this.x, this.y); switch (this.type) { case 'barrel': this.drawBarrel(); break; case 'pipe': this.drawPipe(); break; case 'puddle': this.drawPuddle(); break; case 'bollard': this.drawBollard(); break; case 'rope': this.drawRope(); break; case 'seagull': this.drawSeagull(); break; case 'snake': this.drawSnake(); break; default: ctx.fillStyle = this.color; ctx.fillRect(0, 0, this.width, this.height); } ctx.restore(); } drawSnake() { const w = this.width; const h = this.height; const grad = ctx.createLinearGradient(0, h-10, 0, h+10); grad.addColorStop(0, '#555'); grad.addColorStop(0.5, '#222'); grad.addColorStop(1, '#555'); ctx.strokeStyle = grad; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(0, h); ctx.quadraticCurveTo(w * 0.25, h - 15, w * 0.5, h); ctx.quadraticCurveTo(w * 0.75, h + 15, w, h); ctx.stroke(); } drawSeagull() { ctx.fillStyle = '#E5E7EB'; ctx.strokeStyle = '#9CA3AF'; ctx.lineWidth=1; this.wingFrame += 0.2; const wingY = Math.sin(this.wingFrame) * 10; ctx.beginPath(); ctx.moveTo(this.width/2, this.height/2); ctx.bezierCurveTo(0, -wingY, 0, this.height, this.width/2, this.height*0.7); ctx.bezierCurveTo(this.width, this.height, this.width, -wingY, this.width/2, this.height/2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(this.width * 0.8, this.height*0.4, 8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#F59E0B'; ctx.beginPath(); ctx.moveTo(this.width * 0.8 + 6, this.height*0.4); ctx.lineTo(this.width+10, this.height*0.5); ctx.lineTo(this.width*0.8+6, this.height*0.4+4); ctx.closePath(); ctx.fill(); } drawBarrel() { const w = this.width; const h = this.height; const gradient = ctx.createLinearGradient(0, 0, w, 0); gradient.addColorStop(0, '#A16207'); gradient.addColorStop(0.2, '#FDE047'); gradient.addColorStop(0.8, '#FDE047'); gradient.addColorStop(1, '#A16207'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#854D0E'; ctx.beginPath(); ctx.ellipse(w/2, 0, w/2, 5, 0, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.ellipse(w/2, h, w/2, 5, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#4B5563'; ctx.fillRect(0, h * 0.1, w, h * 0.1); ctx.fillRect(0, h * 0.8, w, h * 0.1); } drawPipe() { const w = this.width; const h = this.height; const gradient = ctx.createLinearGradient(0, 0, w, 0); gradient.addColorStop(0, '#9CA3AF'); gradient.addColorStop(0.5, '#E5E7EB'); gradient.addColorStop(1, '#9CA3AF'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#6B7280'; ctx.beginPath(); ctx.ellipse(w, h/2, 5, h/2, 0, 0, Math.PI * 2); ctx.fill(); } drawPuddle() { const gradient = ctx.createRadialGradient(this.width / 2, this.height, 0, this.width / 2, this.height, this.width/2); gradient.addColorStop(0, 'rgba(127, 255, 212, 0.9)'); gradient.addColorStop(1, 'rgba(72, 61, 139, 0.9)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.ellipse(this.width / 2, this.height, this.width / 2, this.height / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.ellipse(this.width * 0.7, this.height * 0.8, this.width * 0.15, this.height * 0.1, 0, 0, Math.PI * 2); ctx.fill(); } drawBollard() { const w = this.width; const h = this.height; const gradient = ctx.createLinearGradient(0,0,w,0); gradient.addColorStop(0, '#FBBF24'); gradient.addColorStop(0.5, '#FDE68A'); gradient.addColorStop(1, '#FBBF24'); ctx.fillStyle = gradient; ctx.fillRect(0, h*0.2, w, h*0.8); ctx.beginPath(); ctx.ellipse(w/2, h*0.2, w/2, h*0.2, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#1F2937'; ctx.fillRect(0, h * 0.3, w, h * 0.1); ctx.fillRect(0, h * 0.6, w, h * 0.1); } drawRope() { ctx.strokeStyle = '#6D4C41'; ctx.lineWidth = 10; ctx.beginPath(); ctx.moveTo(0, this.height); ctx.quadraticCurveTo(this.width / 2, 0, this.width, this.height); ctx.stroke(); ctx.strokeStyle = '#A1887F'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(0, this.height); ctx.quadraticCurveTo(this.width / 2, 0, this.width, this.height); ctx.stroke(); } }
        
        function handleCoins() { 
             // --- MODIFIED: Spawning is now in handleLevelGeneration ---
            for (let i = coins.length - 1; i >= 0; i--) { 
                const coin = coins[i];
                if(player.animal.name === "RAT" && player.abilityActive) {
                    const dx = player.x - coin.x; const dy = player.y - coin.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 150) { coin.x += dx/dist * 5; coin.y += dy/dist * 5; }
                }
                coin.update(); coin.draw(); 
                const playerCenterX = player.x + player.width / 2; const playerCenterY = player.y + player.height / 2; 
                const dx = Math.abs(coin.x - playerCenterX); const dy = Math.abs(coin.y - playerCenterY); 
                if (dx < player.width / 2 + coin.radius && dy < player.height / 2 + coin.radius) { 
                    score += coin.value; scorePopups.push(new ScorePopup(coin.x, coin.y, coin.value)); coins.splice(i, 1); 
                } else if (coin.x < -20) { coins.splice(i, 1); } 
            } 
        }

        function handlePowerups() { if (frame > 500 && frame % 1000 === 0) { if(Math.random() > 0.4) { const yPos = GROUND_HEIGHT - (Math.random() * 80 + 50); const type = Math.random() > 0.5 ? 'shield' : 'doubleJump'; powerups.push(new PowerUp(canvasWidth, yPos, type)); } } for (let i = powerups.length - 1; i >= 0; i--) { powerups[i].update(); powerups[i].draw(); if ( player.x < powerups[i].x + powerups[i].width && player.x + player.width > powerups[i].x && player.y < powerups[i].y + powerups[i].height && player.y + player.height > powerups[i].y ) { activePowerup = powerups[i].type; powerupTimer = POWERUP_DURATION; if (activePowerup === 'doubleJump') player.canDoubleJump = true; powerups.splice(i, 1); } else if (powerups[i].x + powerups[i].width < 0) { powerups.splice(i, 1); } } if (powerupTimer > 0) { powerupTimer--; if (powerupTimer <= 0) { if (activePowerup === 'doubleJump') player.canDoubleJump = false; activePowerup = null; } } }
        function handleScorePopups() { for (let i = scorePopups.length - 1; i >= 0; i--) { scorePopups[i].update(); scorePopups[i].draw(); if (scorePopups[i].life <= 0) { scorePopups.splice(i, 1); } } }
        let bridgeOffset = 0; let distantShore = [];
        function generateBackgroundElements() { distantShore = []; let currentX = 0; let currentY = canvasHeight * 0.7; while(currentX < canvasWidth * 2) { const segmentWidth = Math.random() * 150 + 50; const nextY = currentY + (Math.random() * 40 - 20); distantShore.push({x1: currentX, y1: currentY, x2: currentX + segmentWidth, y2: nextY}); currentX += segmentWidth; currentY = nextY; } }
        function drawBridge(offsetX) { ctx.save(); ctx.translate(offsetX, 0); ctx.fillStyle = '#2d3748'; const bridgeY = GROUND_HEIGHT - 170; const towerWidth = 30; const towerHeight = 180; const spanLength = 550; for (let i = -1; i < 3; i++) { const towerX = i * spanLength; ctx.beginPath(); ctx.moveTo(towerX, bridgeY); ctx.lineTo(towerX + towerWidth, bridgeY); ctx.lineTo(towerX + towerWidth * 1.5, bridgeY - towerHeight); ctx.lineTo(towerX - towerWidth * 0.5, bridgeY - towerHeight); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(towerX + towerWidth / 2, bridgeY - towerHeight); ctx.lineTo(towerX + spanLength / 2, bridgeY - 50); ctx.lineTo(towerX + spanLength / 2 - 20, bridgeY - 50); ctx.lineTo(towerX + towerWidth / 2, bridgeY - towerHeight + 20); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(towerX + towerWidth / 2, bridgeY - towerHeight); ctx.lineTo(towerX - spanLength / 2, bridgeY - 50); ctx.lineTo(towerX - spanLength / 2 + 20, bridgeY - 50); ctx.lineTo(towerX + towerWidth / 2, bridgeY - towerHeight + 20); ctx.closePath(); ctx.fill(); ctx.fillRect(towerX - spanLength / 2, bridgeY - 50, spanLength, 15); } ctx.restore(); }
        
        function drawPlatforms() { platforms.forEach(p => { const groundGradient = ctx.createLinearGradient(0, p.y, 0, p.y + p.height); groundGradient.addColorStop(0, '#5a5a5a'); groundGradient.addColorStop(0.2, '#4a4a4a'); groundGradient.addColorStop(1, '#2a2a2a'); ctx.fillStyle = groundGradient; ctx.fillRect(p.x, p.y, p.width, p.height); ctx.fillStyle = '#6a6a6a'; ctx.fillRect(p.x, p.y, p.width, 5); }); }

        function handleLevelGeneration() {
            platforms = platforms.filter(p => p.x + p.width > 0);
            obstacles = obstacles.filter(o => o.x + o.width > 0);

            let lastPlatform = platforms[platforms.length - 1];
            while(lastPlatform.x + lastPlatform.width < canvasWidth * 2) {
                let newX = lastPlatform.x + lastPlatform.width;
                let newY = lastPlatform.y;
                let newWidth = Math.random() * 400 + 300;
                
                const action = Math.random();
                if (action < 0.2) { newX += Math.random() * 100 + 80; } 
                else if (action < 0.4) { newY -= Math.random() * 60 + 50; newWidth = Math.random() * 200 + 150; } 
                else if(lastPlatform.y < GROUND_HEIGHT){ newY = GROUND_HEIGHT; }

                const newPlatform = { x: newX, y: newY, width: newWidth, height: 50};
                platforms.push(newPlatform);

                if (Math.random() < 0.5 && newWidth > 150) {
                     const obstacleTypes = ['pipe', 'barrel', 'bollard', 'rope', 'puddle', 'snake'];
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    let ox, oy, owidth, oheight, ocolor;
                     switch(type) {
                        case 'pipe': oheight = Math.random() * 60 + 25; owidth = 35; oy = newPlatform.y - oheight; break;
                        case 'barrel': oheight = 55; owidth = 45; oy = newPlatform.y - oheight; break;
                        case 'bollard': oheight = 40; owidth = 25; oy = newPlatform.y - oheight; break;
                        case 'rope': oheight = 15; owidth = 100; oy = newPlatform.y - oheight; break;
                        case 'puddle': oheight = 10; owidth = 60; oy = newPlatform.y - oheight; break;
                        case 'snake': oheight = 20; owidth = 50; oy = newPlatform.y - oheight; break;
                    }
                    ox = newPlatform.x + Math.random() * (newPlatform.width - owidth);
                    obstacles.push(new Obstacle(type, ox, oy, owidth, oheight, ocolor));
                }

                // --- NEW: Spawn coins on platforms ---
                 if (Math.random() < 0.7 && newWidth > 200) { 
                    const clusterSize = Math.floor(Math.random() * 5) + 3;
                    const startY = newPlatform.y - (Math.random() * 80 + 40); 
                    const startX = newPlatform.x + 50;
                    for(let i = 0; i < clusterSize; i++) {
                        if (startX + (i*40) < newPlatform.x + newPlatform.width - 50) {
                             coins.push(new Coin(startX + (i * 40), startY + Math.sin(i * 0.5) * 30));
                        }
                    }
                }

                lastPlatform = newPlatform;
            }
        }

        function handleCollisions() {
             for (let i = obstacles.length - 1; i >= 0; i--) {
                const o = obstacles[i];
                if ( player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y ) {
                    if (player.animal.name === "RATON LAVEUR" && player.abilityActive) {
                        obstacles.splice(i, 1);
                        player.abilityActive = false; 
                    }
                    else if (activePowerup === 'shield') {
                        obstacles.splice(i, 1); activePowerup = null; powerupTimer = 0;
                    } else {
                        gameState = 'gameOver'; break; 
                    }
                }
            }
        }

        function drawBackground() { 
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvasHeight); skyGradient.addColorStop(0, '#1e2c5e'); skyGradient.addColorStop(0.6, '#9b4a73'); skyGradient.addColorStop(1, '#ff7e5f'); ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, canvasWidth, canvasHeight); ctx.fillStyle = 'rgba(255, 239, 213, 0.8)'; ctx.beginPath(); ctx.arc(canvasWidth * 0.85, canvasHeight * 0.2, 30, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#1a202c'; ctx.beginPath(); ctx.moveTo(0, canvasHeight); distantShore.forEach(seg => { const x = seg.x1 - (bridgeOffset * 0.25); ctx.lineTo(x, seg.y1); }); ctx.lineTo(canvasWidth, canvasHeight); ctx.closePath(); ctx.fill(); bridgeOffset -= gameSpeed * 0.2; if (bridgeOffset < -550) bridgeOffset += 550; drawBridge(bridgeOffset); 
        }
        function drawUI() { 
            ctx.fillStyle = '#FBBF24'; ctx.font = '20px "Press Start 2P"'; ctx.textAlign = 'left'; ctx.fillText(`Score: ${score}`, 20, 40); 
            ctx.textAlign = 'right'; ctx.fillText(`Hi: ${highscore}`, canvasWidth - 20, 40); 
            if (powerupTimer > 0) { ctx.textAlign = 'center'; let powerupText = ''; let powerupColor = ''; if (activePowerup === 'shield') { powerupText = 'Shield!'; powerupColor = '#38bdf8'; } else if (activePowerup === 'doubleJump') { powerupText = 'Double Jump!'; powerupColor = '#f0f9ff'; } ctx.fillStyle = powerupColor; ctx.fillText(powerupText, canvasWidth / 2, 40); const barWidth = 150; const remaining = (powerupTimer / POWERUP_DURATION); ctx.fillStyle = '#4b5563'; ctx.fillRect(canvasWidth / 2 - barWidth / 2, 50, barWidth, 10); ctx.fillStyle = powerupColor; ctx.fillRect(canvasWidth / 2 - barWidth / 2, 50, barWidth * remaining, 10); }
            ctx.textAlign = 'left';
            ctx.fillText("E:", 20, 80);
            const meterWidth = 100; const meterHeight = 15;
            const charge = 1 - (player.abilityCooldown / player.animal.abilityCooldownTime);
            ctx.fillStyle = '#1F2937'; ctx.fillRect(55, 68, meterWidth, meterHeight);
            if(charge >= 1) {
                ctx.fillStyle = '#10B981';
                 if(frame % 20 < 10) ctx.fillStyle = '#6EE7B7'; 
            } else {
                ctx.fillStyle = '#3B82F6';
            }
            ctx.fillRect(55, 68, meterWidth * charge, meterHeight);
            ctx.strokeStyle = 'white'; ctx.strokeRect(55, 68, meterWidth, meterHeight);
        }
        function drawSpeedBoostMessage() { if (speedBoostMessage.timer > 0) { ctx.save(); ctx.textAlign = 'center'; ctx.font = '24px "Press Start 2P"'; ctx.fillStyle = `rgba(251, 191, 36, ${speedBoostMessage.alpha})`; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 5; ctx.fillText(speedBoostMessage.text, canvasWidth / 2, canvasHeight / 3); ctx.restore(); speedBoostMessage.timer--; if (speedBoostMessage.timer > 0) { speedBoostMessage.alpha -= 1 / 60; } else { speedBoostMessage.alpha = 0; } } }
        
        function showCharacterSelectScreen() { ctx.clearRect(0, 0, canvasWidth, canvasHeight); drawBackground(); charSelectUI.style.display = 'block'; titleElement.style.display = 'none'; instructionsElement.style.display = 'none'; const animal = animals[selectedAnimalIndex]; const previewPlayer = { width: animal.width, height: animal.height, isJumping: false, currentFrame: Math.floor(frame / 6) % 2 }; ctx.save(); ctx.translate(canvasWidth/2 - previewPlayer.width/2, canvasHeight/2 - previewPlayer.height/2 - 20); animal.draw(previewPlayer); ctx.restore(); }
        function showStartScreen() { ctx.clearRect(0, 0, canvasWidth, canvasHeight); drawBackground(); drawPlatforms(); player.draw(); ctx.textAlign = 'center'; ctx.fillStyle = 'white'; ctx.font = '30px "Press Start 2P"'; ctx.fillText('COURS PETIT ' + player.animal.name, canvasWidth / 2, canvasHeight / 2 - 40); ctx.font = '16px "Press Start 2P"'; ctx.fillText('Click or Press Space to Start', canvasWidth / 2, canvasHeight / 2); titleElement.style.display = 'block'; instructionsElement.style.display = 'block'; instructionsElement.textContent = "Space: Jump | ArrowDown: Duck | E: Ability | P: Pause"; }
        function showGameOverScreen() { ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvasWidth, canvasHeight); ctx.textAlign = 'center'; ctx.fillStyle = '#EF4444'; ctx.font = '40px "Press Start 2P"'; ctx.fillText('GAME OVER', canvasWidth / 2, canvasHeight / 2 - 60); ctx.fillStyle = 'white'; ctx.font = '20px "Press Start 2P"'; ctx.fillText(`Score: ${score}`, canvasWidth / 2, canvasHeight / 2); if (score > highscore) { ctx.fillStyle = '#FBBF24'; ctx.fillText('New High Score!', canvasWidth / 2, canvasHeight / 2 + 30); highscore = score; localStorage.setItem('refineryRatHighscore', highscore); } ctx.fillStyle = 'white'; ctx.font = '16px "Press Start 2P"'; ctx.fillText('Click to Restart', canvasWidth / 2, canvasHeight / 2 + 80); instructionsElement.textContent = 'Game Over! Click to Restart'; }
        
        function init() { 
            score = 0; gameSpeed = INITIAL_GAME_SPEED; obstacles = []; coins = []; powerups = []; 
            scorePopups = []; frame = 0; 
            platforms = [{x: -100, y: GROUND_HEIGHT, width: canvasWidth + 200, height: 100}];
            player.setCharacter(animals[selectedAnimalIndex]); 
            player.velocityY = 0; player.isDucking = false; player.isJumping = false; 
            player.jumpCount = 0; player.canDoubleJump = false; 
            player.abilityCooldown = 0; player.abilityTimer = 0; player.abilityActive = false;
            activePowerup = null; powerupTimer = 0; 
            gameState = 'playing'; titleElement.style.display = 'none'; instructionsElement.style.display = 'none'; 
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (gameState === 'characterSelect') {
                frame++; showCharacterSelectScreen();
            }
            else if (gameState === 'start') { showStartScreen(); } 
            else if (gameState === 'playing') {
                frame++; score++; gameSpeed += GAME_SPEED_INCREASE;
                if (score > 0 && score % 1500 === 0) {
                    gameSpeed += 0.5; speedBoostMessage.text = 'SPEED BOOST!';
                    speedBoostMessage.timer = 60; speedBoostMessage.alpha = 1.0;
                }
                drawBackground(); 
                handleLevelGeneration(); 
                drawPlatforms(); 

                platforms.forEach(p => p.x -= gameSpeed);
                // --- MODIFIED: Obstacles and coins are moved by their own update functions ---
                obstacles.forEach(o => o.update()); 
                coins.forEach(c => c.update());
                
                obstacles.forEach(o => o.draw()); 
                player.update();
                player.draw();
                handleCollisions();
                handleCoins(); 
                handlePowerups(); 
                drawUI();
                drawSpeedBoostMessage();
                handleScorePopups();
            } else if (gameState === 'gameOver') {
                drawBackground(); drawPlatforms();
                obstacles.forEach(o => o.draw()); 
                player.draw(); coins.forEach(c => c.draw());
                showGameOverScreen();
            } else if (gameState === 'paused') {
                drawBackground(); drawPlatforms();
                obstacles.forEach(o => o.draw());
                player.draw();
                coins.forEach(c => c.draw()); powerups.forEach(p => p.draw()); drawUI();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.textAlign = 'center'; ctx.fillStyle = 'white'; ctx.font = '40px "Press Start 2P"';
                ctx.fillText('PAUSED', canvasWidth / 2, canvasHeight / 2);
            }
            requestAnimationFrame(gameLoop);
        }

        function pressInput() { if (gameState === 'start') { init(); } else if (gameState === 'playing') { player.jump(); player.isJumpButtonHeld = true; } else if (gameState === 'gameOver') { setTimeout(() => { gameState = 'characterSelect'; }, 200); } else if (gameState === 'paused') { gameState = 'playing'; } }
        function releaseInput() { player.isJumpButtonHeld = false; }
        
        function changeCharacter(direction) {
            selectedAnimalIndex += direction;
            if (selectedAnimalIndex < 0) { selectedAnimalIndex = animals.length - 1; } 
            else if (selectedAnimalIndex >= animals.length) { selectedAnimalIndex = 0; }
            charNameElement.textContent = animals[selectedAnimalIndex].name;
            abilityDescElement.textContent = animals[selectedAnimalIndex].abilityDesc;
        }

        prevCharButton.addEventListener('click', () => changeCharacter(-1));
        nextCharButton.addEventListener('click', () => changeCharacter(1));
        selectCharButton.addEventListener('click', () => {
            player.setCharacter(animals[selectedAnimalIndex]);
            charSelectUI.style.display = 'none';
            gameState = 'start';
        });

        window.addEventListener('keydown', (e) => {
            if (gameState === 'characterSelect') {
                if (e.code === 'ArrowLeft') changeCharacter(-1);
                if (e.code === 'ArrowRight') changeCharacter(1);
                if (e.code === 'Space' || e.code === 'Enter') {
                    player.setCharacter(animals[selectedAnimalIndex]);
                    charSelectUI.style.display = 'none';
                    gameState = 'start';
                }
                return;
            }
            if (e.code === 'Space' && e.repeat === false) { e.preventDefault(); pressInput(); }
            if ((e.code === 'ArrowDown' || e.code === 'KeyS') && !e.repeat) { e.preventDefault(); if (gameState === 'playing') player.duck(); }
            if (e.code === 'KeyP') { if (gameState === 'playing') gameState = 'paused'; else if (gameState === 'paused') gameState = 'playing'; }
            if(e.code === 'KeyE' && !e.repeat) { if(gameState === 'playing') player.activateAbility(); }
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') { releaseInput(); }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') { e.preventDefault(); if (gameState === 'playing') player.standUp(); }
        });

        canvas.addEventListener('mousedown', pressInput); canvas.addEventListener('mouseup', releaseInput);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); pressInput(); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); releaseInput(); });

        function resizeCanvas() {
            const container = document.querySelector('.game-container'); const aspectRatio = 16 / 9;
            let newWidth = container.clientWidth * 0.9; let newHeight = newWidth / aspectRatio;
            if (newHeight > container.clientHeight * 0.8) { newHeight = container.clientHeight * 0.8; newWidth = newHeight * aspectRatio; }
            if (window.innerWidth < 800) { newWidth = window.innerWidth * 0.95; newHeight = window.innerHeight * 0.6; }
            canvas.width = newWidth > 800 ? 800 : newWidth; canvas.height = newHeight > 400 ? 400 : newHeight;
            canvasWidth = canvas.width; canvasHeight = canvas.height;
            player.setCharacter(animals[selectedAnimalIndex]);
            generateBackgroundElements();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

